package com.michael.AlgorithmTraining;

import java.util.Scanner;

/*
试题 算法训练 最大最小公倍数
     
资源限制
时间限制：1.0s   内存限制：256.0MB
问题描述
已知一个正整数N，问从1~N中任选出三个数，他们的最小公倍数最大可以为多少。

输入格式
输入一个正整数N。

输出格式
输出一个整数，表示你找到的最小公倍数。
样例输入
9
样例输出
504
数据规模与约定
1 <= N <= 106。
 */
/*
在一组数中找三个数，使他们的最小公倍数最大，我们知道，
两个数的最小公倍数在最大的情况就是当两个数互质的时候，他们的最小公倍数就是这两个数的乘积，
而且还有那么一个定理，^^^^即两个相邻的自然数互质^^^^，即使我们不知道定理怎么证明，但大体能想出来，
但这是三个数，也就是说存在  奇-偶-奇  和 偶-奇-偶 两种情况。

一：奇-偶-奇 这种情况用于n是奇数的情况，即 最大的三个数就是 n，n-1，n-2，那么可以看到，
因为n和n-2都是奇数，所以肯定不存在公因数2，假设三个数中有一个存在因数3，那么另外两个肯定不存在因数3，
因为他们的变化范围都小于3，也就是说，这三个数不仅是最大的，还是互质的，也就是说最大的最小公倍数就是这三个数
的乘积，即n*（n-1）*（n-2）相信大部分人都可以想到这一步



二：偶-奇-偶 对于这种情况两个偶数肯定是存在公因数2，也就是意味着最小公倍数要除以2，这是绝对不能容
忍的，所以我们稍微缩小一下数，即n，n-1，n-3，这样就又变成奇-偶-奇的结构了，但还有一个问题，就是
假如偶数n存在因数3，那么n-3也必定有因数3，这直接导致最小公倍数除以3，更加不能容忍，为了
保持奇-偶-奇的结构不变，只能变那个偶数，而离他最近的偶数就是n-2了，这下就完美了，3个数依然是互质的，
最小公倍数就是（n-1）*（n-2）*（n-3）

题目有点干扰就是，根本就不用任取3个，肯定是找最大的三个数啊

系统有问题，这题提交会错误
 */
public class LargestSmallestCommonMultiple_2 {

	public static void main(String[] args) {
		Scanner sc=new Scanner(System.in);
		int n=sc.nextInt();
		sc.close();
		if(n%2==0){//偶数
			System.out.println((n-1)*(n-2)*(n-3));
		}else{//奇数
			System.out.println(n*(n-1)*(n-2));
		}
	}
}





























